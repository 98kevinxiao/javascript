/******************************************
 * @name 最新技術推送
 * @statement 仅供学习交流|禁止用于商业用途|转载请注明来源
 * @author 𝒀𝒖𝒉𝒆𝒏𝒈
 * @channel https://t.me/yqc_123
 * @version 1.0.0
 * @update 20230630
 * @description CAOLIU技術討論區最新技術推送
******************************************
Quantumult X:
[task_local]
0 8 * * * https://raw.githubusercontent.com/Yuheng0101/X/main/Tasks/1024.js, tag=最新技術推送, img-url=, enabled=true

******************************************/
let scriptName = '草榴技術討論區'
    , $ = 新建 Env(scriptName)
    , request = $.http
    , baseURL = 'https://t66y.com/'
    , $posts = []
    , $postContent = void 0
!(async () => {
    // 获取今日帖子
    await getPosts()
    // 获取随机帖子内容
    const random = (min, max) => Math.floor(Math.random() * (max - min + 1) + min);
    const randomIdx = random(0, $posts.length - 1);
    let postsContent = $posts[randomIdx];
    // 获取最新帖子(u can choose...)
    postsContent = $posts[0];
    await getPostContent(postsContent)
    $.notify(
        `🔔${scriptName}`,
        `《${postsContent.标题}》\n【发布时间】\n${$.time('yyyy-MM-dd HH:mm:ss', postsContent.日期)}`,
        $postContent,
        { 'open-url': postsContent.href }
    )
})()
    。catch((e) => {
        $.log('', `❌ ${$.名字}, 失败! 原因: ${e}!`, '')
    })
    。finally(() => {
        $.已完成()
    });
function getPosts() {
    const url = baseURL + 'thread0806.php?fid=7&search=today'
    return 新建 Promise(async (resolve, reject) => {
        const { 内容: html } = await request.get(url);
        try {
            $posts = html
                。replace(/\n|\s|\r/g, '')
                。match(/<tbody.*?id=\"tbody\">(.*?)<\/tbody>/g)[0]
                。match(/<tbodystyle=\"table-layout:fixed;\"id=\"tbody\">(.*?)<\/tbody>/)[1]
                。match(/<trclass=\"tr3t_onetac"\>(.*?)<\/tr>/g)
                。map(item => {
                    let [, href, 标题, 日期] = item.match(/<h3><ahref=\"(.*?)\".*?>(.*?)<\/a><\/h3>.*?data-timestamp=\"(.*?)\"/);
                    date = Number(date.slice(-1)) ? date : date.slice(0, -1)
                    return { href: baseURL + href, 标题, 日期: date * 1e3 }
                })
                。filter(item => !/\[\d+P\]/。test(item.标题))
            resolve()
        } catch (e) {
            reject(e || '获取帖子失败')
        }
    })
}
function getPostContent(obj) {
    let { href, 标题, 日期 } = obj;
    $.log('', ` 《${标题}》`, '【发布时间】', $.time('yyyy-MM-dd HH:mm:ss', date), '')
    return 新建 Promise(async (resolve, reject) => {
        const { 内容: html } = await request.get(href);
        try {
            $postContent = html.replace(/\n|\s|\r/g, '')
                。match(/<tdbgcolor.*?valign=\"top\">(.*?)<\/td>/)[0]
                。match(/<div.*?id=\"conttpc\">(.*?)<\/div>/)[1]
                。replace(/<br><br>/g, '\n')。replace(/<br>/g, '\n')
                。replace(/&nbsp;/g, '')。replace(/&amp;/g, '&')。replace(/&quot;/g, '"')。replace(/&lt;/g, '<')。replace(/&gt;/g, '>')
                。replace(/<.*?>/g, '')
            resolve()
        } catch (e) {
            reject(e || '获取帖子内容失败')
        }
    })
}
// prettier-ignore
function Env(name, opts) { class Http { constructor(env) { this.env = env } send(opts, method = "GET") { opts = "string" == typeof opts ? { url: opts } : opts; let sender = this.get; return "POST" === method && (sender = this.post), new Promise((resolve, reject) => { sender.call(this, opts, (err, resp, body) => { err ? reject(err) : resolve(resp) }) }) } get(opts) { return this.send.call(this.env, opts) } post(opts) { return this.send.call(this.env, opts, "POST") } } return new class { constructor(name, opts) { this.name = name, this.http = new Http(this), this.data = null, this.dataFile = "box.dat", this.logs = [], this.isMute = !1, this.isNeedRewrite = !1, this.logSeparator = "\n", this.encoding = "utf-8", this.startTime = (new Date).getTime(), Object.assign(this, opts), this.log("", `🔔${this.name}, 开始!`) } getEnv() { return "undefined" != typeof $environment && $environment["surge-version"] ? "Surge" : "undefined" != typeof $environment && $environment["stash-version"] ? "Stash" : "undefined" != typeof module && module.exports ? "Node.js" : "undefined" != typeof $task ? "Quantumult X" : "undefined" != typeof $loon ? "Loon" : "undefined" != typeof $rocket ? "Shadowrocket" : "undefined" != typeof importModule ? "Scriptable" : "function" == typeof require && "undefined" != typeof $jsbox ? "JSBox" : void 0 } isNode() { return "Node.js" === this.getEnv() } isQuanX() { return "Quantumult X" === this.getEnv() } isSurge() { return "Surge" === this.getEnv() } isLoon() { return "Loon" === this.getEnv() } isShadowrocket() { return "Shadowrocket" === this.getEnv() } isStash() { return "Stash" === this.getEnv() } isScriptable() { return "Scriptable" === this.getEnv() } isJSBox() { return "JSBox" === this.getEnv() } toObj(str, defaultValue = null) { try { return JSON.parse(str) } catch { return defaultValue } } toStr(obj, defaultValue = null) { try { return JSON.stringify(obj) } catch { return defaultValue } } getjson(key, defaultValue) { let json = defaultValue; const val = this.getdata(key); if (val) try { json = JSON.parse(this.getdata(key)) } catch { } return json } setjson(val, key) { try { return this.setdata(JSON.stringify(val), key) } catch { return !1 } } getScript(url) { return new Promise(resolve => { this.get({ url: url }, (err, resp, body) => resolve(body)) }) } runScript(script, runOpts) { return new Promise(resolve => { let httpapi = this.getdata("@chavy_boxjs_userCfgs.httpapi"); httpapi = httpapi ? httpapi.replace(/\n/g, "").trim() : httpapi; let httpapi_timeout = this.getdata("@chavy_boxjs_userCfgs.httpapi_timeout"); httpapi_timeout = httpapi_timeout ? 1 * httpapi_timeout : 20, httpapi_timeout = runOpts && runOpts.timeout ? runOpts.timeout : httpapi_timeout; const [key, addr] = httpapi.split("@"), opts = { url: `http://${addr}/v1/scripting/evaluate`, body: { script_text: script, mock_type: "cron", timeout: httpapi_timeout }, headers: { "X-Key": key, Accept: "*/*" }, timeout: httpapi_timeout }; this.post(opts, (err, resp, body) => resolve(body)) }).catch(e => this.logErr(e)) } loaddata() { if (!this.isNode()) return {}; { this.fs = this.fs ? this.fs : require("fs"), this.path = this.path ? this.path : require("path"); const curDirDataFilePath = this.path.resolve(this.dataFile), rootDirDataFilePath = this.path.resolve(process.cwd(), this.dataFile), isCurDirDataFile = this.fs.existsSync(curDirDataFilePath), isRootDirDataFile = !isCurDirDataFile && this.fs.existsSync(rootDirDataFilePath); if (!isCurDirDataFile && !isRootDirDataFile) return {}; { const datPath = isCurDirDataFile ? curDirDataFilePath : rootDirDataFilePath; try { return JSON.parse(this.fs.readFileSync(datPath)) } catch (e) { return {} } } } } writedata() { if (this.isNode()) { this.fs = this.fs ? this.fs : require("fs"), this.path = this.path ? this.path : require("path"); const curDirDataFilePath = this.path.resolve(this.dataFile), rootDirDataFilePath = this.path.resolve(process.cwd(), this.dataFile), isCurDirDataFile = this.fs.existsSync(curDirDataFilePath), isRootDirDataFile = !isCurDirDataFile && this.fs.existsSync(rootDirDataFilePath), jsondata = JSON.stringify(this.data); isCurDirDataFile ? this.fs.writeFileSync(curDirDataFilePath, jsondata) : isRootDirDataFile ? this.fs.writeFileSync(rootDirDataFilePath, jsondata) : this.fs.writeFileSync(curDirDataFilePath, jsondata) } } lodash_get(source, path, defaultValue) { const paths = path.replace(/\[(\d+)\]/g, ".$1").split("."); let result = source; for (const p of paths) if (result = Object(result)[p], void 0 === result) return defaultValue; return result } lodash_set(obj, path, value) { return Object(obj) !== obj ? obj : (Array.isArray(path) || (path = path.toString().match(/[^.[\]]+/g) || []), path.slice(0, -1).reduce((a, c, i) => Object(a[c]) === a[c] ? a[c] : a[c] = Math.abs(path[i + 1]) >> 0 == +path[i + 1] ? [] : {}, obj)[path[path.length - 1]] = value, obj) } getdata(key) { let val = this.getval(key); if (/^@/.test(key)) { const [, objkey, paths] = /^@(.*?)\.(.*?)$/.exec(key), objval = objkey ? this.getval(objkey) : ""; if (objval) try { const objedval = JSON.parse(objval); val = objedval ? this.lodash_get(objedval, paths, "") : val } catch (e) { val = "" } } return val } setdata(val, key) { let issuc = !1; if (/^@/.test(key)) { const [, objkey, paths] = /^@(.*?)\.(.*?)$/.exec(key), objdat = this.getval(objkey), objval = objkey ? "null" === objdat ? null : objdat || "{}" : "{}"; try { const objedval = JSON.parse(objval); this.lodash_set(objedval, paths, val), issuc = this.setval(JSON.stringify(objedval), objkey) } catch (e) { const objedval = {}; this.lodash_set(objedval, paths, val), issuc = this.setval(JSON.stringify(objedval), objkey) } } else issuc = this.setval(val, key); return issuc } getval(key) { switch (this.getEnv()) { case "Surge": case "Loon": case "Stash": case "Shadowrocket": return $persistentStore.read(key); case "Quantumult X": return $prefs.valueForKey(key); case "Node.js": return this.data = this.loaddata(), this.data[key]; default: return this.data && this.data[key] || null } } setval(val, key) { switch (this.getEnv()) { case "Surge": case "Loon": case "Stash": case "Shadowrocket": return $persistentStore.write(val, key); case "Quantumult X": return $prefs.setValueForKey(val, key); case "Node.js": return this.data = this.loaddata(), this.data[key] = val, this.writedata(), !0; default: return this.data && this.data[key] || null } } initGotEnv(opts) { this.got = this.got ? this.got : require("got"), this.cktough = this.cktough ? this.cktough : require("tough-cookie"), this.ckjar = this.ckjar ? this.ckjar : new this.cktough.CookieJar, opts && (opts.headers = opts.headers ? opts.headers : {}, void 0 === opts.headers.Cookie && void 0 === opts.cookieJar && (opts.cookieJar = this.ckjar)) } get(request, callback = (() => { })) { switch (request.headers && (delete request.headers["Content-Type"], delete request.headers["Content-Length"], delete request.headers["content-type"], delete request.headers["content-length"]), this.getEnv()) { case "Surge": case "Loon": case "Stash": case "Shadowrocket": default: this.isSurge() && this.isNeedRewrite && (request.headers = request.headers || {}, Object.assign(request.headers, { "X-Surge-Skip-Scripting": !1 })), $httpClient.get(request, (err, resp, body) => { !err && resp && (resp.body = body, resp.statusCode = resp.status ? resp.status : resp.statusCode, resp.status = resp.statusCode), callback(err, resp, body) }); break; case "Quantumult X": this.isNeedRewrite && (request.opts = request.opts || {}, Object.assign(request.opts, { hints: !1 })), $task.fetch(request).then(resp => { const { statusCode: status, statusCode: statusCode, headers: headers, body: body, bodyBytes: bodyBytes } = resp; callback(null, { status: status, statusCode: statusCode, headers: headers, body: body, bodyBytes: bodyBytes }, body, bodyBytes) }, err => callback(err && err.error || "UndefinedError")); break; case "Node.js": let iconv = require("iconv-lite"); this.initGotEnv(request), this.got(request).on("redirect", (resp, nextOpts) => { try { if (resp.headers["set-cookie"]) { const ck = resp.headers["set-cookie"].map(this.cktough.Cookie.parse).toString(); ck && this.ckjar.setCookieSync(ck, null), nextOpts.cookieJar = this.ckjar } } catch (e) { this.logErr(e) } }).then(resp => { const { statusCode: status, statusCode: statusCode, headers: headers, rawBody: rawBody } = resp, body = iconv.decode(rawBody, this.encoding); callback(null, { status: status, statusCode: statusCode, headers: headers, rawBody: rawBody, body: body }, body) }, err => { const { message: error, response: resp } = err; callback(error, resp, resp && iconv.decode(resp.rawBody, this.encoding)) }) } } post(request, callback = (() => { })) { const method = request.method ? request.method.toLocaleLowerCase() : "post"; switch (request.body && request.headers && !request.headers["Content-Type"] && !request.headers["content-type"] && (request.headers["content-type"] = "application/x-www-form-urlencoded"), request.headers && (delete request.headers["Content-Length"], delete request.headers["content-length"]), this.getEnv()) { case "Surge": case "Loon": case "Stash": case "Shadowrocket": default: this.isSurge() && this.isNeedRewrite && (request.headers = request.headers || {}, Object.assign(request.headers, { "X-Surge-Skip-Scripting": !1 })), $httpClient[method](request, (err, resp, body) => { !err && resp && (resp.body = body, resp.statusCode = resp.status ? resp.status : resp.statusCode, resp.status = resp.statusCode), callback(err, resp, body) }); break; case "Quantumult X": request.method = method, this.isNeedRewrite && (request.opts = request.opts || {}, Object.assign(request.opts, { hints: !1 })), $task.fetch(request).then(resp => { const { statusCode: status, statusCode: statusCode, headers: headers, body: body, bodyBytes: bodyBytes } = resp; callback(null, { status: status, statusCode: statusCode, headers: headers, body: body, bodyBytes: bodyBytes }, body, bodyBytes) }, err => callback(err && err.error || "UndefinedError")); break; case "Node.js": let iconv = require("iconv-lite"); this.initGotEnv(request); const { url: url, ..._request } = request; this.got[method](url, _request).then(resp => { const { statusCode: status, statusCode: statusCode, headers: headers, rawBody: rawBody } = resp, body = iconv.decode(rawBody, this.encoding); callback(null, { status: status, statusCode: statusCode, headers: headers, rawBody: rawBody, body: body }, body) }, err => { const { message: error, response: resp } = err; callback(error, resp, resp && iconv.decode(resp.rawBody, this.encoding)) }) } } time(fmt, ts = null) { const date = ts ? new Date(ts) : new Date; let o = { "M+": date.getMonth() + 1, "d+": date.getDate(), "H+": date.getHours(), "m+": date.getMinutes(), "s+": date.getSeconds(), "q+": Math.floor((date.getMonth() + 3) / 3), S: date.getMilliseconds() }; /(y+)/.test(fmt) && (fmt = fmt.replace(RegExp.$1, (date.getFullYear() + "").substr(4 - RegExp.$1.length))); for (let k in o) new RegExp("(" + k + ")").test(fmt) && (fmt = fmt.replace(RegExp.$1, 1 == RegExp.$1.length ? o[k] : ("00" + o[k]).substr(("" + o[k]).length))); return fmt } queryStr(options) { let queryString = ""; for (const key in options) { let value = options[key]; null != value && "" !== value && ("object" == typeof value && (value = JSON.stringify(value)), queryString += `${key}=${value}&`) } return queryString = queryString.substring(0, queryString.length - 1), queryString } msg(title = name, subt = "", desc = "", opts) { const toEnvOpts = rawopts => { switch (typeof rawopts) { case void 0: return rawopts; case "string": switch (this.getEnv()) { case "Surge": case "Stash": default: return { url: rawopts }; case "Loon": case "Shadowrocket": return rawopts; case "Quantumult X": return { "open-url": rawopts }; case "Node.js": return }case "object": switch (this.getEnv()) { case "Surge": case "Stash": case "Shadowrocket": default: { let openUrl; return { url: rawopts.url || rawopts.openUrl || rawopts["open-url"] } } case "Loon": { let openUrl, mediaUrl; return { openUrl: rawopts.openUrl || rawopts.url || rawopts["open-url"], mediaUrl: rawopts.mediaUrl || rawopts["media-url"] } } case "Quantumult X": { let openUrl, mediaUrl, updatePasteboard; return { "open-url": rawopts["open-url"] || rawopts.url || rawopts.openUrl, "media-url": rawopts["media-url"] || rawopts.mediaUrl, "update-pasteboard": rawopts["update-pasteboard"] || rawopts.updatePasteboard } } case "Node.js": return }default: return } }; if (!this.isMute) switch (this.getEnv()) { case "Surge": case "Loon": case "Stash": case "Shadowrocket": default: $notification.post(title, subt, desc, toEnvOpts(opts)); break; case "Quantumult X": $notify(title, subt, desc, toEnvOpts(opts)); break; case "Node.js": }if (!this.isMuteLog) { let logs = ["", "==============📣系统通知📣=============="]; logs.push(标题), subt && logs.push(subt), desc && logs.push(desc), console.log(logs.join("\n")), this。logs = this。logs。concat(logs) } } notify(标题 = name, subtitle = "", content = "", 选项 = {}) { const openURL = options["open-url"], mediaURL = options["media-url"]; if (this。isQuanX() && $notify(title, subtitle, content, options), this。isSurge() && $notification.post(title, subtitle, content + `${mediaURL ? "\n多媒体:" + mediaURL : ""}`, { url: openURL }), this。isLoon()) { let opts = {}; openURL && (opts.openUrl = openURL), mediaURL && (opts.mediaUrl = mediaURL), "{}" === JSON.stringify(opts) ? $notification.post(title, subtitle, content) : $notification.post(title, subtitle, content, opts) } if (this。isJSBox()) { const content_ = content + (openURL ? `\n点击跳转: ${openURL}` : "") + (mediaURL ? `\n多媒体: ${mediaURL}` : ""), push = require("push"); push.schedule({ 标题: title, 内容: (subtitle ? subtitle + "\n" : "") + content_ }) } if (!this。isMuteLog) { let logs = ["", "==============📣系统通知📣=============="]; logs.push(标题), subtitle && logs.push(subtitle), content && logs.push(content + (openURL ? `\n点击跳转: ${openURL}` : "") + (mediaURL ? `\n多媒体: ${mediaURL}` : "")), console.log(logs.join("\n")), this。logs = this。logs。concat(logs) } } log(...logs) { logs.length > 0 && (this。logs = [...this。logs, ...logs]), console.log(logs.join(this。logSeparator)) } logErr(err, msg) { switch (this。getEnv()) { case "Surge": case "Loon": case "Stash": case "Shadowrocket": case "Quantumult X": 默认: this。log("", `❗️${this。名字}, 错误!`, err); break; case "Node.js": this。log("", `❗️${this。名字}, 错误!`, err.stack) } } wait(time) { return 新建 Promise(resolve => setTimeout(resolve, time)) } 已完成(val = {}) { const endTime = (新建 日期)。getTime(), costTime = (endTime - this。startTime) / 1e3; switch (this。log("", `🔔${this。名字}, 结束! 🕛 ${costTime} 秒`), this。log(), this。getEnv()) { case "Surge": case "Loon": case "Stash": case "Shadowrocket": case "Quantumult X": 默认: $done(val); break; case "Node.js": process.exit(1) } } }(name, opts) }
